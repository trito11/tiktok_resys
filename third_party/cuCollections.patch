diff --git a/.gitignore b/.gitignore
index 4146530..8edb720 100644
--- a/.gitignore
+++ b/.gitignore
@@ -81,9 +81,6 @@ cpp/thirdparty/googletest/
 /html
 /latex
 
-#Java
-target
-
 # Translations
 *.mo
 *.pot
diff --git a/include/cuco/detail/__config b/include/cuco/detail/__config
index c76a1bb..248dff1 100644
--- a/include/cuco/detail/__config
+++ b/include/cuco/detail/__config
@@ -16,7 +16,7 @@
 
  #pragma once
 
- #include <nv/target>
+ #include <cuco/detail/nv/target>
 
 // WAR for libcudacxx/296
 #define CUCO_CUDA_MINIMUM_ARCH _NV_FIRST_ARG(__CUDA_ARCH_LIST__)
diff --git a/include/cuco/detail/nv/detail/__preprocessor b/include/cuco/detail/nv/detail/__preprocessor
new file mode 100644
index 0000000..3485565
--- /dev/null
+++ b/include/cuco/detail/nv/detail/__preprocessor
@@ -0,0 +1,117 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of libcu++, the C++ Standard Library for your entire system,
+// under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#if defined(__GNUC__)
+#pragma GCC system_header
+#endif
+
+// For all compilers and dialects this header defines:
+//  _NV_EVAL
+//  _NV_IF
+//  _NV_CONCAT_EVAL
+// For C++11 and up it defines:
+//  _NV_STRIP_PAREN
+//  _NV_DISPATCH_N_ARY
+//  _NV_FIRST_ARG
+//  _NV_REMOVE_PAREN
+
+#if defined(_NV_TARGET_CPP11)
+#  define _NV_EVAL1(...) __VA_ARGS__
+#  define _NV_EVAL(...) _NV_EVAL1(__VA_ARGS__)
+#else
+#  define _NV_EVAL1(x) x
+#  define _NV_EVAL(x) _NV_EVAL1(x)
+#endif // C++11
+
+#define _NV_CONCAT_EVAL1(l, r) _NV_EVAL(l ## r)
+#define _NV_CONCAT_EVAL(l, r) _NV_CONCAT_EVAL1(l, r)
+
+#define _NV_IF_0(t, f) f
+#define _NV_IF_1(t, f) t
+
+#define _NV_IF_BIT(b) _NV_EVAL(_NV_IF_##b)
+#define _NV_IF__EVAL(fn, t, f) _NV_EVAL(fn(t, f))
+#define _NV_IF_EVAL(cond, t, f) _NV_IF__EVAL(_NV_IF_BIT(cond), t, f)
+
+#define _NV_IF1(cond, t, f) _NV_IF_EVAL(cond, t, f)
+#define _NV_IF(cond, t, f) _NV_IF1(_NV_EVAL(cond), _NV_EVAL(t), _NV_EVAL(f))
+
+#if defined(_NV_TARGET_CPP11)
+
+// The below mechanisms were derived from: https://gustedt.wordpress.com/2010/06/08/detect-empty-macro-arguments/
+
+#define _NV_ARG32(...) _NV_EVAL(_NV_ARG32_0(__VA_ARGS__))
+#define _NV_ARG32_0(                                                                         \
+    _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15,                    \
+    _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, ...) _31
+
+#define _NV_HAS_COMMA(...) _NV_ARG32(__VA_ARGS__,   \
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0)
+
+#define _NV_TRIGGER_PARENTHESIS_(...) ,
+
+#define _NV_ISEMPTY(...)                                                    \
+    _NV_ISEMPTY0(                                                           \
+          /* test if there is just one argument, eventually an empty        \
+             one */                                                         \
+          _NV_EVAL(_NV_HAS_COMMA(__VA_ARGS__)),                                       \
+          /* test if _TRIGGER_PARENTHESIS_ together with the argument       \
+             adds a comma */                                                \
+          _NV_EVAL(_NV_HAS_COMMA(_NV_TRIGGER_PARENTHESIS_ __VA_ARGS__)),              \
+          /* test if the argument together with a parenthesis               \
+             adds a comma */                                                \
+          _NV_EVAL(_NV_HAS_COMMA(__VA_ARGS__ (/*empty*/))),                           \
+          /* test if placing it between _TRIGGER_PARENTHESIS_ and the       \
+             parenthesis adds a comma */                                    \
+          _NV_EVAL(_NV_HAS_COMMA(_NV_TRIGGER_PARENTHESIS_ __VA_ARGS__ (/*empty*/)))   \
+          )
+
+#define _NV_PASTE5(_0, _1, _2, _3, _4) _0 ## _1 ## _2 ## _3 ## _4
+#define _NV_ISEMPTY0(_0, _1, _2, _3) _NV_HAS_COMMA(_NV_PASTE5(_NV_IS_EMPTY_CASE_, _0, _1, _2, _3))
+#define _NV_IS_EMPTY_CASE_0001 ,
+
+
+#define _NV_REMOVE_PAREN(...) _NV_REMOVE_PAREN1(__VA_ARGS__)
+#define _NV_REMOVE_PAREN1(...) _NV_STRIP_PAREN(_NV_IF(_NV_TEST_PAREN(__VA_ARGS__), (_NV_STRIP_PAREN(__VA_ARGS__)), (__VA_ARGS__)))
+
+#define _NV_STRIP_PAREN2(...) __VA_ARGS__
+#define _NV_STRIP_PAREN1(...) _NV_STRIP_PAREN2 __VA_ARGS__
+#define _NV_STRIP_PAREN(...) _NV_STRIP_PAREN1(__VA_ARGS__)
+
+#define _NV_TEST_PAREN(...) _NV_TEST_PAREN1(__VA_ARGS__)
+#define _NV_TEST_PAREN1(...) _NV_TEST_PAREN2(_NV_TEST_PAREN_DUMMY __VA_ARGS__)
+#define _NV_TEST_PAREN2(...) _NV_TEST_PAREN3(_NV_CONCAT_EVAL(_, __VA_ARGS__))
+#define _NV_TEST_PAREN3(...) _NV_EVAL(_NV_FIRST_ARG(__VA_ARGS__))
+
+#define __NV_PAREN_YES 1
+#define __NV_PAREN_NO 0
+
+#define _NV_TEST_PAREN_DUMMY(...) _NV_PAREN_YES
+#define __NV_TEST_PAREN_DUMMY     __NV_PAREN_NO,
+
+#define _NV_FIRST_ARG1(x, ...) x
+#define _NV_FIRST_ARG(x, ...) _NV_FIRST_ARG1(x)
+
+#define _NV_REMOVE_FIRST_ARGS1(...) __VA_ARGS__
+#define _NV_REMOVE_FIRST_ARGS(x, ...) _NV_REMOVE_FIRST_ARGS1(__VA_ARGS__)
+
+#define _NV_NUM_ARGS(...) _NV_NUM_ARGS0(__VA_ARGS__)
+#define _NV_NUM_ARGS0(...) _NV_EVAL(_NV_NUM_ARGS1(__VA_ARGS__))
+#define _NV_NUM_ARGS1(...) _NV_IF(_NV_ISEMPTY(__VA_ARGS__), 0, _NV_NUM_ARGS2(__VA_ARGS__))
+#define _NV_NUM_ARGS2(...) _NV_ARG32(__VA_ARGS__,   \
+    31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16, \
+    15,14,13,12,11,10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
+
+#define _NV_DISPATCH_N_IMPL1(name, ...) _NV_EVAL(name(__VA_ARGS__))
+#define _NV_DISPATCH_N_IMPL0(depth, name, ...) _NV_DISPATCH_N_IMPL1(_NV_CONCAT_EVAL(name, depth), __VA_ARGS__)
+#define _NV_DISPATCH_N_IMPL(name, ...) _NV_DISPATCH_N_IMPL0(_NV_NUM_ARGS(__VA_ARGS__), name, __VA_ARGS__)
+#define _NV_DISPATCH_N_ARY(name, ...) _NV_DISPATCH_N_IMPL(name, __VA_ARGS__)
+
+#endif // C++11
\ No newline at end of file
diff --git a/include/cuco/detail/nv/detail/__target_macros b/include/cuco/detail/nv/detail/__target_macros
new file mode 100644
index 0000000..d67d923
--- /dev/null
+++ b/include/cuco/detail/nv/detail/__target_macros
@@ -0,0 +1,472 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of libcu++, the C++ Standard Library for your entire system,
+// under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef _NV__TARGET_MACROS
+#define _NV__TARGET_MACROS
+
+#include "__preprocessor"
+
+#if defined(__GNUC__)
+#pragma GCC system_header
+#endif
+
+#  define _NV_TARGET_ARCH_TO_SELECTOR_350 nv::target::sm_35
+#  define _NV_TARGET_ARCH_TO_SELECTOR_370 nv::target::sm_37
+#  define _NV_TARGET_ARCH_TO_SELECTOR_500 nv::target::sm_50
+#  define _NV_TARGET_ARCH_TO_SELECTOR_520 nv::target::sm_52
+#  define _NV_TARGET_ARCH_TO_SELECTOR_530 nv::target::sm_53
+#  define _NV_TARGET_ARCH_TO_SELECTOR_600 nv::target::sm_60
+#  define _NV_TARGET_ARCH_TO_SELECTOR_610 nv::target::sm_61
+#  define _NV_TARGET_ARCH_TO_SELECTOR_620 nv::target::sm_62
+#  define _NV_TARGET_ARCH_TO_SELECTOR_700 nv::target::sm_70
+#  define _NV_TARGET_ARCH_TO_SELECTOR_720 nv::target::sm_72
+#  define _NV_TARGET_ARCH_TO_SELECTOR_750 nv::target::sm_75
+#  define _NV_TARGET_ARCH_TO_SELECTOR_800 nv::target::sm_80
+#  define _NV_TARGET_ARCH_TO_SELECTOR_860 nv::target::sm_86
+#  define _NV_TARGET_ARCH_TO_SELECTOR_870 nv::target::sm_87
+
+#  define _NV_TARGET_ARCH_TO_SM_350 35
+#  define _NV_TARGET_ARCH_TO_SM_370 37
+#  define _NV_TARGET_ARCH_TO_SM_500 50
+#  define _NV_TARGET_ARCH_TO_SM_520 52
+#  define _NV_TARGET_ARCH_TO_SM_530 53
+#  define _NV_TARGET_ARCH_TO_SM_600 60
+#  define _NV_TARGET_ARCH_TO_SM_610 61
+#  define _NV_TARGET_ARCH_TO_SM_620 62
+#  define _NV_TARGET_ARCH_TO_SM_700 70
+#  define _NV_TARGET_ARCH_TO_SM_720 72
+#  define _NV_TARGET_ARCH_TO_SM_750 75
+#  define _NV_TARGET_ARCH_TO_SM_800 80
+#  define _NV_TARGET_ARCH_TO_SM_860 86
+#  define _NV_TARGET_ARCH_TO_SM_870 87
+
+// Only enable when compiling for CUDA/stdpar
+#if defined(_NV_COMPILER_NVCXX) && defined(_NVHPC_CUDA)
+
+#  define _NV_TARGET_VAL_SM_35 nv::target::sm_35
+#  define _NV_TARGET_VAL_SM_37 nv::target::sm_37
+#  define _NV_TARGET_VAL_SM_50 nv::target::sm_50
+#  define _NV_TARGET_VAL_SM_52 nv::target::sm_52
+#  define _NV_TARGET_VAL_SM_53 nv::target::sm_53
+#  define _NV_TARGET_VAL_SM_60 nv::target::sm_60
+#  define _NV_TARGET_VAL_SM_61 nv::target::sm_61
+#  define _NV_TARGET_VAL_SM_62 nv::target::sm_62
+#  define _NV_TARGET_VAL_SM_70 nv::target::sm_70
+#  define _NV_TARGET_VAL_SM_72 nv::target::sm_72
+#  define _NV_TARGET_VAL_SM_75 nv::target::sm_75
+#  define _NV_TARGET_VAL_SM_80 nv::target::sm_80
+#  define _NV_TARGET_VAL_SM_86 nv::target::sm_86
+#  define _NV_TARGET_VAL_SM_87 nv::target::sm_87
+
+#  define _NV_TARGET___NV_IS_HOST nv::target::is_host
+#  define _NV_TARGET___NV_IS_DEVICE nv::target::is_device
+
+#  define _NV_TARGET___NV_ANY_TARGET (nv::target::any_target)
+#  define _NV_TARGET___NV_NO_TARGET (nv::target::no_target)
+
+#  if defined(NV_TARGET_SM_INTEGER_LIST)
+#    define NV_TARGET_MINIMUM_SM_SELECTOR _NV_FIRST_ARG(NV_TARGET_SM_SELECTOR_LIST)
+#    define NV_TARGET_MINIMUM_SM_INTEGER _NV_FIRST_ARG(NV_TARGET_SM_INTEGER_LIST)
+#    define __CUDA_MINIMUM_ARCH__ _NV_CONCAT_EVAL(_NV_FIRST_ARG(NV_TARGET_SM_INTEGER_LIST), 0)
+#  endif
+
+#  define _NV_TARGET_PROVIDES(q)   nv::target::provides(q)
+#  define _NV_TARGET_IS_EXACTLY(q) nv::target::is_exactly(q)
+
+#elif defined(_NV_COMPILER_NVCC) || defined (_NV_COMPILER_CLANG_CUDA)
+
+#  define _NV_TARGET_VAL_SM_35 350
+#  define _NV_TARGET_VAL_SM_37 370
+#  define _NV_TARGET_VAL_SM_50 500
+#  define _NV_TARGET_VAL_SM_52 520
+#  define _NV_TARGET_VAL_SM_53 530
+#  define _NV_TARGET_VAL_SM_60 600
+#  define _NV_TARGET_VAL_SM_61 610
+#  define _NV_TARGET_VAL_SM_62 620
+#  define _NV_TARGET_VAL_SM_70 700
+#  define _NV_TARGET_VAL_SM_72 720
+#  define _NV_TARGET_VAL_SM_75 750
+#  define _NV_TARGET_VAL_SM_80 800
+#  define _NV_TARGET_VAL_SM_86 860
+#  define _NV_TARGET_VAL_SM_87 870
+
+#  if defined(__CUDA_ARCH__)
+#    define _NV_TARGET_VAL __CUDA_ARCH__
+#    define NV_TARGET_MINIMUM_SM_SELECTOR _NV_CONCAT_EVAL(_NV_TARGET_ARCH_TO_SELECTOR_, __CUDA_ARCH__)
+#    define NV_TARGET_MINIMUM_SM_INTEGER _NV_CONCAT_EVAL(_NV_TARGET_ARCH_TO_SM_, __CUDA_ARCH__)
+#    define __CUDA_MINIMUM_ARCH__ __CUDA_ARCH__
+#  endif
+
+#  if defined(__CUDA_ARCH__)
+#    define _NV_TARGET_IS_HOST   0
+#    define _NV_TARGET_IS_DEVICE 1
+#  else
+#    define _NV_TARGET_IS_HOST   1
+#    define _NV_TARGET_IS_DEVICE 0
+#  endif
+
+#  if defined(_NV_TARGET_VAL)
+#    define _NV_DEVICE_CHECK(q) (q)
+#  else
+#    define _NV_DEVICE_CHECK(q) (0)
+#  endif
+
+#  define _NV_TARGET_PROVIDES(q)   _NV_DEVICE_CHECK(_NV_TARGET_VAL >= q)
+#  define _NV_TARGET_IS_EXACTLY(q) _NV_DEVICE_CHECK(_NV_TARGET_VAL == q)
+
+// NVCC/NVCXX not being used, only host dispatches allowed
+#else
+
+#  define _NV_COMPILER_NVCC
+
+#  define _NV_TARGET_VAL_SM_35 350
+#  define _NV_TARGET_VAL_SM_37 370
+#  define _NV_TARGET_VAL_SM_50 500
+#  define _NV_TARGET_VAL_SM_52 520
+#  define _NV_TARGET_VAL_SM_53 530
+#  define _NV_TARGET_VAL_SM_60 600
+#  define _NV_TARGET_VAL_SM_61 610
+#  define _NV_TARGET_VAL_SM_62 620
+#  define _NV_TARGET_VAL_SM_70 700
+#  define _NV_TARGET_VAL_SM_72 720
+#  define _NV_TARGET_VAL_SM_75 750
+#  define _NV_TARGET_VAL_SM_80 800
+#  define _NV_TARGET_VAL_SM_86 860
+#  define _NV_TARGET_VAL_SM_87 870
+
+#  define _NV_TARGET_VAL 0
+
+#  define _NV_TARGET_IS_HOST   1
+#  define _NV_TARGET_IS_DEVICE 0
+
+#  define _NV_DEVICE_CHECK(q) (false)
+
+#  define _NV_TARGET_PROVIDES(q)   _NV_DEVICE_CHECK(_NV_TARGET_VAL >= q)
+#  define _NV_TARGET_IS_EXACTLY(q) _NV_DEVICE_CHECK(_NV_TARGET_VAL == q)
+
+#endif
+
+#define _NV_TARGET___NV_PROVIDES_SM_35 (_NV_TARGET_PROVIDES(_NV_TARGET_VAL_SM_35))
+#define _NV_TARGET___NV_PROVIDES_SM_37 (_NV_TARGET_PROVIDES(_NV_TARGET_VAL_SM_37))
+#define _NV_TARGET___NV_PROVIDES_SM_50 (_NV_TARGET_PROVIDES(_NV_TARGET_VAL_SM_50))
+#define _NV_TARGET___NV_PROVIDES_SM_52 (_NV_TARGET_PROVIDES(_NV_TARGET_VAL_SM_52))
+#define _NV_TARGET___NV_PROVIDES_SM_53 (_NV_TARGET_PROVIDES(_NV_TARGET_VAL_SM_53))
+#define _NV_TARGET___NV_PROVIDES_SM_60 (_NV_TARGET_PROVIDES(_NV_TARGET_VAL_SM_60))
+#define _NV_TARGET___NV_PROVIDES_SM_61 (_NV_TARGET_PROVIDES(_NV_TARGET_VAL_SM_61))
+#define _NV_TARGET___NV_PROVIDES_SM_62 (_NV_TARGET_PROVIDES(_NV_TARGET_VAL_SM_62))
+#define _NV_TARGET___NV_PROVIDES_SM_70 (_NV_TARGET_PROVIDES(_NV_TARGET_VAL_SM_70))
+#define _NV_TARGET___NV_PROVIDES_SM_72 (_NV_TARGET_PROVIDES(_NV_TARGET_VAL_SM_72))
+#define _NV_TARGET___NV_PROVIDES_SM_75 (_NV_TARGET_PROVIDES(_NV_TARGET_VAL_SM_75))
+#define _NV_TARGET___NV_PROVIDES_SM_80 (_NV_TARGET_PROVIDES(_NV_TARGET_VAL_SM_80))
+#define _NV_TARGET___NV_PROVIDES_SM_86 (_NV_TARGET_PROVIDES(_NV_TARGET_VAL_SM_86))
+#define _NV_TARGET___NV_PROVIDES_SM_87 (_NV_TARGET_PROVIDES(_NV_TARGET_VAL_SM_87))
+
+#define _NV_TARGET___NV_IS_EXACTLY_SM_35 (_NV_TARGET_IS_EXACTLY(_NV_TARGET_VAL_SM_35))
+#define _NV_TARGET___NV_IS_EXACTLY_SM_37 (_NV_TARGET_IS_EXACTLY(_NV_TARGET_VAL_SM_37))
+#define _NV_TARGET___NV_IS_EXACTLY_SM_50 (_NV_TARGET_IS_EXACTLY(_NV_TARGET_VAL_SM_50))
+#define _NV_TARGET___NV_IS_EXACTLY_SM_52 (_NV_TARGET_IS_EXACTLY(_NV_TARGET_VAL_SM_52))
+#define _NV_TARGET___NV_IS_EXACTLY_SM_53 (_NV_TARGET_IS_EXACTLY(_NV_TARGET_VAL_SM_53))
+#define _NV_TARGET___NV_IS_EXACTLY_SM_60 (_NV_TARGET_IS_EXACTLY(_NV_TARGET_VAL_SM_60))
+#define _NV_TARGET___NV_IS_EXACTLY_SM_61 (_NV_TARGET_IS_EXACTLY(_NV_TARGET_VAL_SM_61))
+#define _NV_TARGET___NV_IS_EXACTLY_SM_62 (_NV_TARGET_IS_EXACTLY(_NV_TARGET_VAL_SM_62))
+#define _NV_TARGET___NV_IS_EXACTLY_SM_70 (_NV_TARGET_IS_EXACTLY(_NV_TARGET_VAL_SM_70))
+#define _NV_TARGET___NV_IS_EXACTLY_SM_72 (_NV_TARGET_IS_EXACTLY(_NV_TARGET_VAL_SM_72))
+#define _NV_TARGET___NV_IS_EXACTLY_SM_75 (_NV_TARGET_IS_EXACTLY(_NV_TARGET_VAL_SM_75))
+#define _NV_TARGET___NV_IS_EXACTLY_SM_80 (_NV_TARGET_IS_EXACTLY(_NV_TARGET_VAL_SM_80))
+#define _NV_TARGET___NV_IS_EXACTLY_SM_86 (_NV_TARGET_IS_EXACTLY(_NV_TARGET_VAL_SM_86))
+#define _NV_TARGET___NV_IS_EXACTLY_SM_87 (_NV_TARGET_IS_EXACTLY(_NV_TARGET_VAL_SM_87))
+
+#define NV_PROVIDES_SM_35   __NV_PROVIDES_SM_35
+#define NV_PROVIDES_SM_37   __NV_PROVIDES_SM_37
+#define NV_PROVIDES_SM_50   __NV_PROVIDES_SM_50
+#define NV_PROVIDES_SM_52   __NV_PROVIDES_SM_52
+#define NV_PROVIDES_SM_53   __NV_PROVIDES_SM_53
+#define NV_PROVIDES_SM_60   __NV_PROVIDES_SM_60
+#define NV_PROVIDES_SM_61   __NV_PROVIDES_SM_61
+#define NV_PROVIDES_SM_62   __NV_PROVIDES_SM_62
+#define NV_PROVIDES_SM_70   __NV_PROVIDES_SM_70
+#define NV_PROVIDES_SM_72   __NV_PROVIDES_SM_72
+#define NV_PROVIDES_SM_75   __NV_PROVIDES_SM_75
+#define NV_PROVIDES_SM_80   __NV_PROVIDES_SM_80
+#define NV_PROVIDES_SM_86   __NV_PROVIDES_SM_86
+#define NV_PROVIDES_SM_87   __NV_PROVIDES_SM_87
+
+#define NV_IS_EXACTLY_SM_35 __NV_IS_EXACTLY_SM_35
+#define NV_IS_EXACTLY_SM_37 __NV_IS_EXACTLY_SM_37
+#define NV_IS_EXACTLY_SM_50 __NV_IS_EXACTLY_SM_50
+#define NV_IS_EXACTLY_SM_52 __NV_IS_EXACTLY_SM_52
+#define NV_IS_EXACTLY_SM_53 __NV_IS_EXACTLY_SM_53
+#define NV_IS_EXACTLY_SM_60 __NV_IS_EXACTLY_SM_60
+#define NV_IS_EXACTLY_SM_61 __NV_IS_EXACTLY_SM_61
+#define NV_IS_EXACTLY_SM_62 __NV_IS_EXACTLY_SM_62
+#define NV_IS_EXACTLY_SM_70 __NV_IS_EXACTLY_SM_70
+#define NV_IS_EXACTLY_SM_72 __NV_IS_EXACTLY_SM_72
+#define NV_IS_EXACTLY_SM_75 __NV_IS_EXACTLY_SM_75
+#define NV_IS_EXACTLY_SM_80 __NV_IS_EXACTLY_SM_80
+#define NV_IS_EXACTLY_SM_86 __NV_IS_EXACTLY_SM_86
+#define NV_IS_EXACTLY_SM_87 __NV_IS_EXACTLY_SM_87
+
+#define NV_IS_HOST         __NV_IS_HOST
+#define NV_IS_DEVICE       __NV_IS_DEVICE
+
+#define NV_ANY_TARGET      __NV_ANY_TARGET
+#define NV_NO_TARGET       __NV_NO_TARGET
+
+// Platform invoke mechanisms
+#if defined(_NV_COMPILER_NVCXX) && defined(_NVHPC_CUDA)
+
+#  define _NV_ARCH_COND(q) (_NV_TARGET_##q)
+
+#  define _NV_BLOCK_EXPAND(...) _NV_REMOVE_PAREN(__VA_ARGS__)
+
+#  define _NV_TARGET_IF(cond, t, ...) \
+    (if target _NV_ARCH_COND(cond) {    \
+      _NV_BLOCK_EXPAND(t)        \
+    } else { _NV_BLOCK_EXPAND(__VA_ARGS__) })
+
+#elif defined(_NV_COMPILER_NVCC) || defined (_NV_COMPILER_CLANG_CUDA)
+
+#  if (_NV_TARGET___NV_IS_EXACTLY_SM_35)
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_35 1
+#  else
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_35 0
+#  endif
+
+#  if (_NV_TARGET___NV_IS_EXACTLY_SM_37)
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_37 1
+#  else
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_37 0
+#  endif
+
+#  if (_NV_TARGET___NV_IS_EXACTLY_SM_50)
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_50 1
+#  else
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_50 0
+#  endif
+
+#  if (_NV_TARGET___NV_IS_EXACTLY_SM_52)
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_52 1
+#  else
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_52 0
+#  endif
+
+#  if (_NV_TARGET___NV_IS_EXACTLY_SM_53)
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_53 1
+#  else
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_53 0
+#  endif
+
+#  if (_NV_TARGET___NV_IS_EXACTLY_SM_60)
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_60 1
+#  else
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_60 0
+#  endif
+
+#  if (_NV_TARGET___NV_IS_EXACTLY_SM_61)
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_61 1
+#  else
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_61 0
+#  endif
+
+#  if (_NV_TARGET___NV_IS_EXACTLY_SM_62)
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_62 1
+#  else
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_62 0
+#  endif
+
+#  if (_NV_TARGET___NV_IS_EXACTLY_SM_70)
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_70 1
+#  else
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_70 0
+#  endif
+
+#  if (_NV_TARGET___NV_IS_EXACTLY_SM_72)
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_72 1
+#  else
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_72 0
+#  endif
+
+#  if (_NV_TARGET___NV_IS_EXACTLY_SM_75)
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_75 1
+#  else
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_75 0
+#  endif
+
+#  if (_NV_TARGET___NV_IS_EXACTLY_SM_80)
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_80 1
+#  else
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_80 0
+#  endif
+
+#  if (_NV_TARGET___NV_IS_EXACTLY_SM_86)
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_86 1
+#  else
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_86 0
+#  endif
+
+#  if (_NV_TARGET___NV_IS_EXACTLY_SM_87)
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_87 1
+#  else
+#    define _NV_TARGET_BOOL___NV_IS_EXACTLY_SM_87 0
+#  endif
+
+#  if (_NV_TARGET_IS_HOST)
+#    define _NV_TARGET_BOOL___NV_IS_HOST   1
+#    define _NV_TARGET_BOOL___NV_IS_DEVICE 0
+#  else
+#    define _NV_TARGET_BOOL___NV_IS_HOST   0
+#    define _NV_TARGET_BOOL___NV_IS_DEVICE 1
+#  endif
+
+#  define _NV_TARGET_BOOL___NV_ANY_TARGET 1
+#  define _NV_TARGET_BOOL___NV_NO_TARGET 0
+
+// NVCC Greater than stuff
+
+#  if (_NV_TARGET___NV_PROVIDES_SM_35)
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_35 1
+#  else
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_35 0
+#  endif
+
+#  if (_NV_TARGET___NV_PROVIDES_SM_37)
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_37 1
+#  else
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_37 0
+#  endif
+
+#  if (_NV_TARGET___NV_PROVIDES_SM_50)
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_50 1
+#  else
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_50 0
+#  endif
+
+#  if (_NV_TARGET___NV_PROVIDES_SM_52)
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_52 1
+#  else
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_52 0
+#  endif
+
+#  if (_NV_TARGET___NV_PROVIDES_SM_53)
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_53 1
+#  else
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_53 0
+#  endif
+
+#  if (_NV_TARGET___NV_PROVIDES_SM_60)
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_60 1
+#  else
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_60 0
+#  endif
+
+#  if (_NV_TARGET___NV_PROVIDES_SM_61)
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_61 1
+#  else
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_61 0
+#  endif
+
+#  if (_NV_TARGET___NV_PROVIDES_SM_62)
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_62 1
+#  else
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_62 0
+#  endif
+
+#  if (_NV_TARGET___NV_PROVIDES_SM_70)
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_70 1
+#  else
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_70 0
+#  endif
+
+#  if (_NV_TARGET___NV_PROVIDES_SM_72)
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_72 1
+#  else
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_72 0
+#  endif
+
+#  if (_NV_TARGET___NV_PROVIDES_SM_75)
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_75 1
+#  else
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_75 0
+#  endif
+
+#  if (_NV_TARGET___NV_PROVIDES_SM_80)
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_80 1
+#  else
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_80 0
+#  endif
+
+#  if (_NV_TARGET___NV_PROVIDES_SM_86)
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_86 1
+#  else
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_86 0
+#  endif
+
+#  if (_NV_TARGET___NV_PROVIDES_SM_87)
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_87 1
+#  else
+#    define _NV_TARGET_BOOL___NV_PROVIDES_SM_87 0
+#  endif
+
+#  define _NV_ARCH_COND_CAT1(cond) _NV_TARGET_BOOL_##cond
+#  define _NV_ARCH_COND_CAT(cond) _NV_EVAL(_NV_ARCH_COND_CAT1(cond))
+
+#    define _NV_TARGET_EMPTY_PARAM ;
+
+#  if defined(_NV_TARGET_CPP11)
+
+#    define _NV_BLOCK_EXPAND(...) { _NV_REMOVE_PAREN(__VA_ARGS__) }
+#    define _NV_TARGET_IF(cond, t, ...) _NV_IF( _NV_ARCH_COND_CAT(cond), t, __VA_ARGS__)
+
+#  else // <C++11 fallback
+
+#    define _NV_BLOCK_EXPAND(x) { x }
+
+#    define _NV_TARGET_IF(cond, t)         _NV_IF(_NV_ARCH_COND_CAT(cond), t, _NV_TARGET_EMPTY_PARAM)
+#    define _NV_TARGET_IF_ELSE(cond, t, f) _NV_IF(_NV_ARCH_COND_CAT(cond), t, f)
+
+#  endif
+
+#endif // _NV_COMPILER_NVCC
+
+#if defined(_NV_TARGET_CPP11)
+
+#  define _NV_TARGET_DISPATCH_HANDLE0()
+#  define _NV_TARGET_DISPATCH_HANDLE2(q, fn)        _NV_TARGET_IF(q, fn)
+#  define _NV_TARGET_DISPATCH_HANDLE4(q, fn, ...)   _NV_TARGET_IF(q, fn, _NV_TARGET_DISPATCH_HANDLE2(__VA_ARGS__))
+#  define _NV_TARGET_DISPATCH_HANDLE6(q, fn, ...)   _NV_TARGET_IF(q, fn, _NV_TARGET_DISPATCH_HANDLE4(__VA_ARGS__))
+#  define _NV_TARGET_DISPATCH_HANDLE8(q, fn, ...)   _NV_TARGET_IF(q, fn, _NV_TARGET_DISPATCH_HANDLE6(__VA_ARGS__))
+#  define _NV_TARGET_DISPATCH_HANDLE10(q, fn, ...)  _NV_TARGET_IF(q, fn, _NV_TARGET_DISPATCH_HANDLE8(__VA_ARGS__))
+#  define _NV_TARGET_DISPATCH_HANDLE12(q, fn, ...)  _NV_TARGET_IF(q, fn, _NV_TARGET_DISPATCH_HANDLE10(__VA_ARGS__))
+#  define _NV_TARGET_DISPATCH_HANDLE14(q, fn, ...)  _NV_TARGET_IF(q, fn, _NV_TARGET_DISPATCH_HANDLE12(__VA_ARGS__))
+#  define _NV_TARGET_DISPATCH_HANDLE16(q, fn, ...)  _NV_TARGET_IF(q, fn, _NV_TARGET_DISPATCH_HANDLE14(__VA_ARGS__))
+#  define _NV_TARGET_DISPATCH_HANDLE18(q, fn, ...)  _NV_TARGET_IF(q, fn, _NV_TARGET_DISPATCH_HANDLE16(__VA_ARGS__))
+#  define _NV_TARGET_DISPATCH_HANDLE20(q, fn, ...)  _NV_TARGET_IF(q, fn, _NV_TARGET_DISPATCH_HANDLE18(__VA_ARGS__))
+#  define _NV_TARGET_DISPATCH_HANDLE22(q, fn, ...)  _NV_TARGET_IF(q, fn, _NV_TARGET_DISPATCH_HANDLE20(__VA_ARGS__))
+#  define _NV_TARGET_DISPATCH_HANDLE24(q, fn, ...)  _NV_TARGET_IF(q, fn, _NV_TARGET_DISPATCH_HANDLE22(__VA_ARGS__))
+#  define _NV_TARGET_DISPATCH_HANDLE26(q, fn, ...)  _NV_TARGET_IF(q, fn, _NV_TARGET_DISPATCH_HANDLE24(__VA_ARGS__))
+#  define _NV_TARGET_DISPATCH_HANDLE28(q, fn, ...)  _NV_TARGET_IF(q, fn, _NV_TARGET_DISPATCH_HANDLE26(__VA_ARGS__))
+#  define _NV_TARGET_DISPATCH_HANDLE30(q, fn, ...)  _NV_TARGET_IF(q, fn, _NV_TARGET_DISPATCH_HANDLE28(__VA_ARGS__))
+#  define _NV_TARGET_DISPATCH_HANDLE32(q, fn, ...)  _NV_TARGET_IF(q, fn, _NV_TARGET_DISPATCH_HANDLE30(__VA_ARGS__))
+
+#  define _NV_TARGET_DISPATCH(...) _NV_BLOCK_EXPAND(_NV_DISPATCH_N_ARY(_NV_TARGET_DISPATCH_HANDLE, __VA_ARGS__))
+
+// NV_IF_TARGET supports a false statement provided as a variadic macro
+#  define NV_IF_TARGET(cond, ...)    _NV_BLOCK_EXPAND(_NV_TARGET_IF(cond, __VA_ARGS__))
+#  define NV_IF_ELSE_TARGET(cond, t, f) _NV_BLOCK_EXPAND(_NV_TARGET_IF(cond, t, f))
+#  define NV_DISPATCH_TARGET(...)       _NV_TARGET_DISPATCH(__VA_ARGS__)
+
+#else // <C++11 fallback
+
+// NV_IF_TARGET does not support a fallback false statement in C++03 or C dialects
+#  define NV_IF_TARGET(cond, t)         _NV_BLOCK_EXPAND(_NV_TARGET_IF(cond, t))
+#  define NV_IF_ELSE_TARGET(cond, t, f) _NV_BLOCK_EXPAND(_NV_TARGET_IF_ELSE(cond, t, f))
+
+#endif
+
+#endif // _NV__TARGET_MACROS
\ No newline at end of file
diff --git a/include/cuco/detail/nv/target b/include/cuco/detail/nv/target
new file mode 100644
index 0000000..f199ee7
--- /dev/null
+++ b/include/cuco/detail/nv/target
@@ -0,0 +1,201 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of libcu++, the C++ Standard Library for your entire system,
+// under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// This header contains a preview of a portability system that enables
+// CUDA C++ development with NVC++, NVCC, and supported host compilers.
+// These interfaces are not guaranteed to be stable.
+
+#ifndef __NV_TARGET_H
+#define __NV_TARGET_H
+
+#if defined(__NVCC__) || defined(__CUDACC_RTC__)
+#  define _NV_COMPILER_NVCC
+#elif defined(__NVCOMPILER) && __cplusplus >= 201103L
+#  define _NV_COMPILER_NVCXX
+#elif defined(__clang__) && defined(__CUDA__) && defined(__CUDA_ARCH__)
+// clang compiling CUDA code, device mode.
+#  define _NV_COMPILER_CLANG_CUDA
+#endif
+
+#if defined(__CUDACC_RTC__)
+#  define _NV_FUNCTION_ANNOTATION __device__
+#else
+#  define _NV_FUNCTION_ANNOTATION
+#endif
+
+#if defined(_NV_COMPILER_NVCXX)
+#  define _NV_BITSET_ATTRIBUTE [[nv::__target_bitset]]
+#else
+#  define _NV_BITSET_ATTRIBUTE
+#endif
+
+#if (!defined(__ibmxl__)) && \
+    ((defined(__cplusplus) && __cplusplus >= 201103L) || \
+     (defined(_MSC_VER) && _MSVC_LANG >= 201103L))
+#  define _NV_TARGET_CPP11
+#endif
+
+#if defined(_NV_TARGET_CPP11)
+
+namespace nv {
+  namespace target {
+    namespace detail {
+
+      typedef unsigned long long base_int_t;
+
+      // No host specialization
+      constexpr base_int_t all_hosts = 1;
+
+      // NVIDIA GPUs
+      constexpr base_int_t sm_35_bit = 1 << 1;
+      constexpr base_int_t sm_37_bit = 1 << 2;
+      constexpr base_int_t sm_50_bit = 1 << 3;
+      constexpr base_int_t sm_52_bit = 1 << 4;
+      constexpr base_int_t sm_53_bit = 1 << 5;
+      constexpr base_int_t sm_60_bit = 1 << 6;
+      constexpr base_int_t sm_61_bit = 1 << 7;
+      constexpr base_int_t sm_62_bit = 1 << 8;
+      constexpr base_int_t sm_70_bit = 1 << 9;
+      constexpr base_int_t sm_72_bit = 1 << 10;
+      constexpr base_int_t sm_75_bit = 1 << 11;
+      constexpr base_int_t sm_80_bit = 1 << 12;
+      constexpr base_int_t sm_86_bit = 1 << 13;
+      constexpr base_int_t sm_87_bit = 1 << 14;
+      constexpr base_int_t all_devices =
+          sm_35_bit | sm_37_bit |
+          sm_50_bit | sm_52_bit | sm_53_bit |
+          sm_60_bit | sm_61_bit | sm_62_bit |
+          sm_70_bit | sm_72_bit | sm_75_bit |
+          sm_80_bit | sm_86_bit | sm_87_bit;
+
+      // Store a set of targets as a set of bits
+      struct _NV_BITSET_ATTRIBUTE target_description {
+        base_int_t targets;
+        _NV_FUNCTION_ANNOTATION
+        constexpr target_description(base_int_t a) : targets(a) { }
+      };
+
+      // The type of the user-visible names of the NVIDIA GPU targets
+      enum class sm_selector : base_int_t {
+        sm_35 = 35, sm_37 = 37,
+        sm_50 = 50, sm_52 = 52, sm_53 = 53,
+        sm_60 = 60, sm_61 = 61, sm_62 = 62,
+        sm_70 = 70, sm_72 = 72, sm_75 = 75,
+        sm_80 = 80, sm_86 = 86, sm_87 = 87,
+      };
+      _NV_FUNCTION_ANNOTATION
+      constexpr base_int_t toint(sm_selector a) {
+        return static_cast<base_int_t>(a);
+      }
+      _NV_FUNCTION_ANNOTATION
+      constexpr base_int_t bitexact(sm_selector a) {
+        return toint(a) == 35 ? sm_35_bit :
+               toint(a) == 37 ? sm_37_bit :
+               toint(a) == 50 ? sm_50_bit :
+               toint(a) == 52 ? sm_52_bit :
+               toint(a) == 53 ? sm_53_bit :
+               toint(a) == 60 ? sm_60_bit :
+               toint(a) == 61 ? sm_61_bit :
+               toint(a) == 62 ? sm_62_bit :
+               toint(a) == 70 ? sm_70_bit :
+               toint(a) == 72 ? sm_72_bit :
+               toint(a) == 75 ? sm_75_bit :
+               toint(a) == 80 ? sm_80_bit :
+               toint(a) == 86 ? sm_86_bit :
+               toint(a) == 87 ? sm_87_bit : 0;
+      }
+      _NV_FUNCTION_ANNOTATION
+      constexpr base_int_t bitrounddown(sm_selector a) {
+        return toint(a) >= 87 ? sm_87_bit :
+               toint(a) >= 86 ? sm_86_bit :
+               toint(a) >= 80 ? sm_80_bit :
+               toint(a) >= 75 ? sm_75_bit :
+               toint(a) >= 72 ? sm_72_bit :
+               toint(a) >= 70 ? sm_70_bit :
+               toint(a) >= 62 ? sm_62_bit :
+               toint(a) >= 61 ? sm_61_bit :
+               toint(a) >= 60 ? sm_60_bit :
+               toint(a) >= 53 ? sm_53_bit :
+               toint(a) >= 52 ? sm_52_bit :
+               toint(a) >= 50 ? sm_50_bit :
+               toint(a) >= 37 ? sm_37_bit :
+               toint(a) >= 35 ? sm_35_bit : 0;
+      }
+
+      // Public API for NVIDIA GPUs
+
+      _NV_FUNCTION_ANNOTATION
+      constexpr target_description is_exactly(sm_selector a) {
+        return target_description(bitexact(a));
+      }
+
+      _NV_FUNCTION_ANNOTATION
+      constexpr target_description provides(sm_selector a) {
+        return target_description(~(bitrounddown(a) - 1) & all_devices);
+      }
+
+      // Boolean operations on target sets
+
+      _NV_FUNCTION_ANNOTATION
+      constexpr target_description operator&&(target_description a,
+                                              target_description b) {
+        return target_description(a.targets & b.targets);
+      }
+
+      _NV_FUNCTION_ANNOTATION
+      constexpr target_description operator||(target_description a,
+                                              target_description b) {
+        return target_description(a.targets | b.targets);
+      }
+
+      _NV_FUNCTION_ANNOTATION
+      constexpr target_description operator!(target_description a) {
+        return target_description(~a.targets & (all_devices | all_hosts));
+      }
+    }
+
+    using detail::target_description;
+    using detail::sm_selector;
+
+    // The predicates for basic host/device selection
+    constexpr target_description is_host =
+      target_description(detail::all_hosts);
+    constexpr target_description is_device =
+      target_description(detail::all_devices);
+    constexpr target_description any_target =
+      target_description(detail::all_hosts | detail::all_devices);
+    constexpr target_description no_target =
+      target_description(0);
+
+    // The public names for NVIDIA GPU architectures
+    constexpr sm_selector sm_35 = sm_selector::sm_35;
+    constexpr sm_selector sm_37 = sm_selector::sm_37;
+    constexpr sm_selector sm_50 = sm_selector::sm_50;
+    constexpr sm_selector sm_52 = sm_selector::sm_52;
+    constexpr sm_selector sm_53 = sm_selector::sm_53;
+    constexpr sm_selector sm_60 = sm_selector::sm_60;
+    constexpr sm_selector sm_61 = sm_selector::sm_61;
+    constexpr sm_selector sm_62 = sm_selector::sm_62;
+    constexpr sm_selector sm_70 = sm_selector::sm_70;
+    constexpr sm_selector sm_72 = sm_selector::sm_72;
+    constexpr sm_selector sm_75 = sm_selector::sm_75;
+    constexpr sm_selector sm_80 = sm_selector::sm_80;
+    constexpr sm_selector sm_86 = sm_selector::sm_86;
+    constexpr sm_selector sm_87 = sm_selector::sm_87;
+
+    using detail::is_exactly;
+    using detail::provides;
+  }
+}
+
+#endif // C++11
+
+#include "detail/__target_macros"
+
+#endif // __NV_TARGET_H
\ No newline at end of file
diff --git a/include/cuco/detail/pair.cuh b/include/cuco/detail/pair.cuh
index 7ea3988..846728b 100644
--- a/include/cuco/detail/pair.cuh
+++ b/include/cuco/detail/pair.cuh
@@ -24,6 +24,39 @@
 #include <algorithm>
 #include <tuple>
 #include <type_traits>
+namespace std {
+template <class...>
+using void_t = void;
+
+template <bool B>
+using bool_constant = std::integral_constant<bool, B>;
+
+template <typename _Tp>
+struct has_unique_object_representations : bool_constant<__has_unique_object_representations(std::remove_cv_t<std::remove_all_extents_t<_Tp>>)> {};
+
+template <class T>
+inline constexpr bool has_unique_object_representations_v = has_unique_object_representations<T>::value;
+
+// Fangzhou Ai @ 2022/07/07 3:28 PM PST
+// This deprecated function cast is for older veriosn of cuCollection
+// template< class From, class To >
+// inline constexpr bool is_convertible_v = is_convertible<From, To>::value;
+
+template <typename Key, typename ProbeKey, typename KeyEqual>
+struct is_invocable :
+    std::is_constructible<
+        std::function<void(ProbeKey, KeyEqual)>,
+        std::reference_wrapper<typename std::remove_reference<Key>::type>
+    >
+{
+};
+
+template <typename Key, typename ProbeKey, typename KeyEqual>
+inline constexpr bool is_invocable_v = is_invocable<Key, ProbeKey, KeyEqual>::value;
+
+template <typename Base, typename Derived>
+inline constexpr bool is_base_of_v = is_base_of<Base, Derived>::value;
+} // namespace std
 
 namespace cuco {
 namespace detail {
diff --git a/include/cuco/detail/static_map.inl b/include/cuco/detail/static_map.inl
index 09e9d05..5e16f13 100644
--- a/include/cuco/detail/static_map.inl
+++ b/include/cuco/detail/static_map.inl
@@ -25,50 +25,17 @@
 #include <cub/device/device_select.cuh>
 
 namespace cuco {
-
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
-static_map<Key, Value, Scope, Allocator>::static_map(
-  std::size_t capacity,
-  sentinel::empty_key<Key> empty_key_sentinel,
-  sentinel::empty_value<Value> empty_value_sentinel,
-  Allocator const& alloc,
-  cudaStream_t stream)
-  : capacity_{std::max(capacity, std::size_t{1})},  // to avoid dereferencing a nullptr (Issue #72)
-    empty_key_sentinel_{empty_key_sentinel.value},
-    empty_value_sentinel_{empty_value_sentinel.value},
-    erased_key_sentinel_{empty_key_sentinel.value},
-    slot_allocator_{alloc},
-    counter_allocator_{alloc}
-{
-  slots_         = std::allocator_traits<slot_allocator_type>::allocate(slot_allocator_, capacity_);
-  num_successes_ = std::allocator_traits<counter_allocator_type>::allocate(counter_allocator_, 1);
-
-  auto constexpr block_size = 256;
-  auto constexpr stride     = 4;
-  auto const grid_size      = (capacity_ + stride * block_size - 1) / (stride * block_size);
-  detail::initialize<block_size, atomic_key_type, atomic_mapped_type>
-    <<<grid_size, block_size, 0, stream>>>(
-      slots_, empty_key_sentinel_, empty_value_sentinel_, capacity_);
-}
-
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
-static_map<Key, Value, Scope, Allocator>::static_map(
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
+static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::static_map(
   std::size_t capacity,
-  sentinel::empty_key<Key> empty_key_sentinel,
-  sentinel::empty_value<Value> empty_value_sentinel,
-  sentinel::erased_key<Key> erased_key_sentinel,
   Allocator const& alloc,
   cudaStream_t stream)
   : capacity_{std::max(capacity, std::size_t{1})},  // to avoid dereferencing a nullptr (Issue #72)
-    empty_key_sentinel_{empty_key_sentinel.value},
-    empty_value_sentinel_{empty_value_sentinel.value},
-    erased_key_sentinel_{erased_key_sentinel.value},
     slot_allocator_{alloc},
     counter_allocator_{alloc}
 {
-  CUCO_RUNTIME_EXPECTS(empty_key_sentinel_ != erased_key_sentinel_,
-                       "The empty key sentinel and erased key sentinel cannot be the same value.");
-
   slots_         = std::allocator_traits<slot_allocator_type>::allocate(slot_allocator_, capacity_);
   num_successes_ = std::allocator_traits<counter_allocator_type>::allocate(counter_allocator_, 1);
 
@@ -80,16 +47,20 @@ static_map<Key, Value, Scope, Allocator>::static_map(
       slots_, empty_key_sentinel_, empty_value_sentinel_, capacity_);
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
-static_map<Key, Value, Scope, Allocator>::~static_map()
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
+static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::~static_map()
 {
   std::allocator_traits<slot_allocator_type>::deallocate(slot_allocator_, slots_, capacity_);
   std::allocator_traits<counter_allocator_type>::deallocate(counter_allocator_, num_successes_, 1);
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename InputIt, typename Hash, typename KeyEqual>
-void static_map<Key, Value, Scope, Allocator>::insert(
+void static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::insert(
   InputIt first, InputIt last, Hash hash, KeyEqual key_equal, cudaStream_t stream)
 {
   auto num_keys = std::distance(first, last);
@@ -116,13 +87,15 @@ void static_map<Key, Value, Scope, Allocator>::insert(
   size_ += h_num_successes;
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename InputIt,
           typename StencilIt,
           typename Predicate,
           typename Hash,
           typename KeyEqual>
-void static_map<Key, Value, Scope, Allocator>::insert_if(InputIt first,
+void static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::insert_if(InputIt first,
                                                          InputIt last,
                                                          StencilIt stencil,
                                                          Predicate pred,
@@ -153,14 +126,13 @@ void static_map<Key, Value, Scope, Allocator>::insert_if(InputIt first,
   size_ += h_num_successes;
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename InputIt, typename Hash, typename KeyEqual>
-void static_map<Key, Value, Scope, Allocator>::erase(
+void static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::erase(
   InputIt first, InputIt last, Hash hash, KeyEqual key_equal, cudaStream_t stream)
 {
-  CUCO_RUNTIME_EXPECTS(get_empty_key_sentinel() != get_erased_key_sentinel(),
-                       "You must provide a unique erased key sentinel value at map construction.");
-
   auto num_keys = std::distance(first, last);
   if (num_keys == 0) { return; }
 
@@ -185,9 +157,11 @@ void static_map<Key, Value, Scope, Allocator>::erase(
   size_ -= h_num_successes;
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename InputIt, typename OutputIt, typename Hash, typename KeyEqual>
-void static_map<Key, Value, Scope, Allocator>::find(InputIt first,
+void static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::find(InputIt first,
                                                     InputIt last,
                                                     OutputIt output_begin,
                                                     Hash hash,
@@ -207,9 +181,11 @@ void static_map<Key, Value, Scope, Allocator>::find(InputIt first,
     <<<grid_size, block_size, 0, stream>>>(first, last, output_begin, view, hash, key_equal);
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename KeyOut, typename ValueOut>
-std::pair<KeyOut, ValueOut> static_map<Key, Value, Scope, Allocator>::retrieve_all(
+std::pair<KeyOut, ValueOut> static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::retrieve_all(
   KeyOut keys_out, ValueOut values_out, cudaStream_t stream)
 {
   static_assert(sizeof(pair_atomic_type) == sizeof(value_type));
@@ -251,12 +227,19 @@ std::pair<KeyOut, ValueOut> static_map<Key, Value, Scope, Allocator>::retrieve_a
     cudaMemcpyAsync(&h_num_out, d_num_out, sizeof(std::size_t), cudaMemcpyDeviceToHost, stream));
   CUCO_CUDA_TRY(cudaStreamSynchronize(stream));
 
+  std::allocator_traits<temp_allocator_type>::deallocate(
+    temp_allocator, reinterpret_cast<char*>(d_num_out), sizeof(std::size_t));
+  std::allocator_traits<temp_allocator_type>::deallocate(
+    temp_allocator, d_temp_storage, temp_storage_bytes);
+
   return std::make_pair(keys_out + h_num_out, values_out + h_num_out);
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename InputIt, typename OutputIt, typename Hash, typename KeyEqual>
-void static_map<Key, Value, Scope, Allocator>::contains(InputIt first,
+void static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::contains(InputIt first,
                                                         InputIt last,
                                                         OutputIt output_begin,
                                                         Hash hash,
@@ -276,10 +259,12 @@ void static_map<Key, Value, Scope, Allocator>::contains(InputIt first,
     <<<grid_size, block_size, 0, stream>>>(first, last, output_begin, view, hash, key_equal);
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename KeyEqual>
-__device__ static_map<Key, Value, Scope, Allocator>::device_mutable_view::insert_result
-static_map<Key, Value, Scope, Allocator>::device_mutable_view::packed_cas(
+__device__ static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_mutable_view::insert_result
+static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_mutable_view::packed_cas(
   iterator current_slot,
   value_type const& insert_pair,
   KeyEqual key_equal,
@@ -308,10 +293,12 @@ static_map<Key, Value, Scope, Allocator>::device_mutable_view::packed_cas(
   return insert_result::CONTINUE;
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename KeyEqual>
-__device__ static_map<Key, Value, Scope, Allocator>::device_mutable_view::insert_result
-static_map<Key, Value, Scope, Allocator>::device_mutable_view::back_to_back_cas(
+__device__ static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_mutable_view::insert_result
+static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_mutable_view::back_to_back_cas(
   iterator current_slot,
   value_type const& insert_pair,
   KeyEqual key_equal,
@@ -348,10 +335,12 @@ static_map<Key, Value, Scope, Allocator>::device_mutable_view::back_to_back_cas(
   return insert_result::CONTINUE;
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename KeyEqual>
-__device__ static_map<Key, Value, Scope, Allocator>::device_mutable_view::insert_result
-static_map<Key, Value, Scope, Allocator>::device_mutable_view::cas_dependent_write(
+__device__ static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_mutable_view::insert_result
+static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_mutable_view::cas_dependent_write(
   iterator current_slot,
   value_type const& insert_pair,
   KeyEqual key_equal,
@@ -376,9 +365,11 @@ static_map<Key, Value, Scope, Allocator>::device_mutable_view::cas_dependent_wri
   return insert_result::CONTINUE;
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename Hash, typename KeyEqual>
-__device__ bool static_map<Key, Value, Scope, Allocator>::device_mutable_view::insert(
+__device__ bool static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_mutable_view::insert(
   value_type const& insert_pair, Hash hash, KeyEqual key_equal) noexcept
 {
   auto current_slot{initial_slot(insert_pair.first, hash)};
@@ -422,12 +413,14 @@ __device__ bool static_map<Key, Value, Scope, Allocator>::device_mutable_view::i
   }
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename Hash, typename KeyEqual>
 __device__
-  thrust::pair<typename static_map<Key, Value, Scope, Allocator>::device_mutable_view::iterator,
+  thrust::pair<typename static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_mutable_view::iterator,
                bool>
-  static_map<Key, Value, Scope, Allocator>::device_mutable_view::insert_and_find(
+  static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_mutable_view::insert_and_find(
     value_type const& insert_pair, Hash hash, KeyEqual key_equal) noexcept
 {
 #if __CUDA_ARCH__ < 700
@@ -512,9 +505,11 @@ __device__
   }
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename CG, typename Hash, typename KeyEqual>
-__device__ bool static_map<Key, Value, Scope, Allocator>::device_mutable_view::insert(
+__device__ bool static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_mutable_view::insert(
   CG const& g, value_type const& insert_pair, Hash hash, KeyEqual key_equal) noexcept
 {
   auto current_slot = initial_slot(g, insert_pair.first, hash);
@@ -576,9 +571,11 @@ __device__ bool static_map<Key, Value, Scope, Allocator>::device_mutable_view::i
   }
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename Hash, typename KeyEqual>
-__device__ bool static_map<Key, Value, Scope, Allocator>::device_mutable_view::erase(
+__device__ bool static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_mutable_view::erase(
   key_type const& k, Hash hash, KeyEqual key_equal) noexcept
 {
   auto current_slot{initial_slot(k, hash)};
@@ -622,9 +619,11 @@ __device__ bool static_map<Key, Value, Scope, Allocator>::device_mutable_view::e
   }
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename CG, typename Hash, typename KeyEqual>
-__device__ bool static_map<Key, Value, Scope, Allocator>::device_mutable_view::erase(
+__device__ bool static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_mutable_view::erase(
   CG const& g, key_type const& k, Hash hash, KeyEqual key_equal) noexcept
 {
   auto current_slot = initial_slot(g, k, hash);
@@ -680,10 +679,12 @@ __device__ bool static_map<Key, Value, Scope, Allocator>::device_mutable_view::e
   }
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename Hash, typename KeyEqual>
-__device__ typename static_map<Key, Value, Scope, Allocator>::device_view::iterator
-static_map<Key, Value, Scope, Allocator>::device_view::find(Key const& k,
+__device__ typename static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_view::iterator
+static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_view::find(Key const& k,
                                                             Hash hash,
                                                             KeyEqual key_equal) noexcept
 {
@@ -703,10 +704,12 @@ static_map<Key, Value, Scope, Allocator>::device_view::find(Key const& k,
   }
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename Hash, typename KeyEqual>
-__device__ typename static_map<Key, Value, Scope, Allocator>::device_view::const_iterator
-static_map<Key, Value, Scope, Allocator>::device_view::find(Key const& k,
+__device__ typename static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_view::const_iterator
+static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_view::find(Key const& k,
                                                             Hash hash,
                                                             KeyEqual key_equal) const noexcept
 {
@@ -726,13 +729,15 @@ static_map<Key, Value, Scope, Allocator>::device_view::find(Key const& k,
   }
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename CG, typename Hash, typename KeyEqual>
-__device__ typename static_map<Key, Value, Scope, Allocator>::device_view::iterator
-static_map<Key, Value, Scope, Allocator>::device_view::find(CG g,
+__device__ typename static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_view::iterator
+static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_view::find(CG g,
                                                             Key const& k,
                                                             Hash hash,
-                                                            KeyEqual key_equal) noexcept
+                                                            KeyEqual key_equal) const noexcept
 {
   auto current_slot = initial_slot(g, k, hash);
 
@@ -764,49 +769,11 @@ static_map<Key, Value, Scope, Allocator>::device_view::find(CG g,
   }
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
-template <typename CG, typename Hash, typename KeyEqual>
-__device__ typename static_map<Key, Value, Scope, Allocator>::device_view::const_iterator
-static_map<Key, Value, Scope, Allocator>::device_view::find(CG g,
-                                                            Key const& k,
-                                                            Hash hash,
-                                                            KeyEqual key_equal) const noexcept
-{
-  auto current_slot = initial_slot(g, k, hash);
-
-  while (true) {
-    auto const existing_key = current_slot->first.load(cuda::std::memory_order_relaxed);
-
-    // The user provide `key_equal` can never be used to compare against `empty_key_sentinel` as
-    // the sentinel is not a valid key value. Therefore, first check for the sentinel
-    auto const slot_is_empty =
-      detail::bitwise_compare(existing_key, this->get_empty_key_sentinel());
-
-    // the key we were searching for was found by one of the threads, so we return an iterator to
-    // the entry
-    auto const exists = g.ballot(not slot_is_empty and key_equal(existing_key, k));
-    if (exists) {
-      uint32_t src_lane = __ffs(exists) - 1;
-      // TODO: This shouldn't cast an iterator to an int to shuffle. Instead, get the index of the
-      // current_slot and shuffle that instead.
-      intptr_t res_slot = g.shfl(reinterpret_cast<intptr_t>(current_slot), src_lane);
-      return reinterpret_cast<const_iterator>(res_slot);
-    }
-
-    // we found an empty slot, meaning that the key we're searching
-    // for isn't in this submap, so we should move onto the next one
-    if (g.ballot(slot_is_empty)) { return this->end(); }
-
-    // otherwise, all slots in the current window are full with other keys,
-    // so we move onto the next window in the current submap
-
-    current_slot = next_slot(g, current_slot);
-  }
-}
-
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename ProbeKey, typename Hash, typename KeyEqual>
-__device__ bool static_map<Key, Value, Scope, Allocator>::device_view::contains(
+__device__ bool static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_view::contains(
   ProbeKey const& k, Hash hash, KeyEqual key_equal) const noexcept
 {
   auto current_slot = initial_slot(k, hash);
@@ -822,10 +789,12 @@ __device__ bool static_map<Key, Value, Scope, Allocator>::device_view::contains(
   }
 }
 
-template <typename Key, typename Value, cuda::thread_scope Scope, typename Allocator>
+template <typename Key, typename Value, 
+          Key empty_key_sentinel, Value empty_value_sentinel, Key erased_key_sentinel,
+          cuda::thread_scope Scope, typename Allocator>
 template <typename CG, typename ProbeKey, typename Hash, typename KeyEqual>
 __device__ std::enable_if_t<std::is_invocable_v<KeyEqual, ProbeKey, Key>, bool>
-static_map<Key, Value, Scope, Allocator>::device_view::contains(CG const& g,
+static_map<Key, Value, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel, Scope, Allocator>::device_view::contains(CG const& g,
                                                                 ProbeKey const& k,
                                                                 Hash hash,
                                                                 KeyEqual key_equal) const noexcept
diff --git a/include/cuco/static_map.cuh b/include/cuco/static_map.cuh
index 1daad99..25f7532 100644
--- a/include/cuco/static_map.cuh
+++ b/include/cuco/static_map.cuh
@@ -22,7 +22,6 @@
 #include <cuco/detail/hash_functions.cuh>
 #include <cuco/detail/pair.cuh>
 #include <cuco/detail/static_map_kernels.cuh>
-#include <cuco/sentinel.cuh>
 #include <cuco/traits.hpp>
 
 #include <thrust/functional.h>
@@ -121,6 +120,9 @@ class dynamic_map;
  */
 template <typename Key,
           typename Value,
+          Key empty_key_sentinel,
+          Value empty_value_sentinel,
+          Key erased_key_sentinel,
           cuda::thread_scope Scope = cuda::thread_scope_device,
           typename Allocator       = cuco::cuda_allocator<char>>
 class static_map {
@@ -135,7 +137,6 @@ class static_map {
                 "cuco::is_bitwise_comparable_v<Value>.");
 
   friend class dynamic_map<Key, Value, Scope, Allocator>;  ///< Dynamic map as friend class
-
  public:
   using value_type         = cuco::pair_type<Key, Value>;       ///< Type of key/value pairs
   using key_type           = Key;                               ///< Key type
@@ -194,35 +195,10 @@ class static_map {
    * that contains either.
    *
    * @param capacity The total number of slots in the map
-   * @param empty_key_sentinel The reserved key value for empty slots
-   * @param empty_value_sentinel The reserved mapped value for empty slots
-   * @param alloc Allocator used for allocating device storage
-   * @param stream Stream used for executing the kernels
-   */
-  static_map(std::size_t capacity,
-             sentinel::empty_key<Key> empty_key_sentinel,
-             sentinel::empty_value<Value> empty_value_sentinel,
-             Allocator const& alloc = Allocator{},
-             cudaStream_t stream    = 0);
-
-  /**
-   * @brief Constructs a fixed-size map with erase capability.
-   * empty_key_sentinel and erased_key_sentinel must be different values.
-   *
-   * @throw std::runtime error if the empty key sentinel and erased key sentinel
-   * are the same value
-   *
-   * @param capacity The total number of slots in the map
-   * @param empty_key_sentinel The reserved key value for empty slots
-   * @param empty_value_sentinel The reserved mapped value for empty slots
-   * @param erased_key_sentinel The reserved value to denote erased slots
    * @param alloc Allocator used for allocating device storage
    * @param stream Stream used for executing the kernels
    */
   static_map(std::size_t capacity,
-             sentinel::empty_key<Key> empty_key_sentinel,
-             sentinel::empty_value<Value> empty_value_sentinel,
-             sentinel::erased_key<Key> erased_key_sentinel,
              Allocator const& alloc = Allocator{},
              cudaStream_t stream    = 0);
 
@@ -416,9 +392,8 @@ class static_map {
                 KeyEqual key_equal  = KeyEqual{},
                 cudaStream_t stream = 0) const;
 
- private:
-  class device_view_base {
-   protected:
+  class __align__(16) device_view_base {
+   public:
     // Import member type definitions from `static_map`
     using value_type     = value_type;
     using key_type       = Key;
@@ -427,34 +402,13 @@ class static_map {
     using const_iterator = pair_atomic_type const*;
     using slot_type      = slot_type;
 
-    Key empty_key_sentinel_{};      ///< Key value that represents an empty slot
-    Key erased_key_sentinel_{};     ///< Key value that represents an erased slot
-    Value empty_value_sentinel_{};  ///< Initial Value of empty slot
     pair_atomic_type* slots_{};     ///< Pointer to flat slots storage
     std::size_t capacity_{};        ///< Total number of slots
 
     __host__ __device__ device_view_base(pair_atomic_type* slots,
-                                         std::size_t capacity,
-                                         sentinel::empty_key<Key> empty_key_sentinel,
-                                         sentinel::empty_value<Value> empty_value_sentinel) noexcept
-      : slots_{slots},
-        capacity_{capacity},
-        empty_key_sentinel_{empty_key_sentinel.value},
-        erased_key_sentinel_{empty_key_sentinel.value},
-        empty_value_sentinel_{empty_value_sentinel.value}
-    {
-    }
-
-    __host__ __device__ device_view_base(pair_atomic_type* slots,
-                                         std::size_t capacity,
-                                         sentinel::empty_key<Key> empty_key_sentinel,
-                                         sentinel::empty_value<Value> empty_value_sentinel,
-                                         sentinel::erased_key<Key> erased_key_sentinel) noexcept
+                                         std::size_t capacity) noexcept
       : slots_{slots},
-        capacity_{capacity},
-        empty_key_sentinel_{empty_key_sentinel.value},
-        erased_key_sentinel_{erased_key_sentinel.value},
-        empty_value_sentinel_{empty_value_sentinel.value}
+        capacity_{capacity}
     {
     }
 
@@ -505,27 +459,7 @@ class static_map {
      * @return Pointer to the initial slot for `k`
      */
     template <typename CG, typename ProbeKey, typename Hash>
-    __device__ iterator initial_slot(CG const& g, ProbeKey const& k, Hash hash) noexcept
-    {
-      return &slots_[(hash(k) + g.thread_rank()) % capacity_];
-    }
-
-    /**
-     * @brief Returns the initial slot for a given key `k`
-     *
-     * To be used for Cooperative Group based probing.
-     *
-     * @tparam CG Cooperative Group type
-     * @tparam ProbeKey Probe key type
-     * @tparam Hash Unary callable type
-     *
-     * @param g the Cooperative Group for which the initial slot is needed
-     * @param k The key to get the slot for
-     * @param hash The unary callable used to hash the key
-     * @return Pointer to the initial slot for `k`
-     */
-    template <typename CG, typename ProbeKey, typename Hash>
-    __device__ const_iterator initial_slot(CG const& g, ProbeKey const& k, Hash hash) const noexcept
+    __device__ iterator initial_slot(CG const& g, ProbeKey const& k, Hash hash) const noexcept
     {
       return &slots_[(hash(k) + g.thread_rank()) % capacity_];
     }
@@ -565,7 +499,7 @@ class static_map {
      * @return The next slot after `s`
      */
     template <typename CG>
-    __device__ iterator next_slot(CG const& g, iterator s) noexcept
+    __device__ iterator next_slot(CG const& g, iterator s) const noexcept
     {
       uint32_t index = s - slots_;
       return &slots_[(index + g.size()) % capacity_];
@@ -643,22 +577,16 @@ class static_map {
      *
      * @return The sentinel value used to represent an empty key slot
      */
-    __host__ __device__ Key get_empty_key_sentinel() const noexcept { return empty_key_sentinel_; }
+    static constexpr Key get_empty_key_sentinel() { return empty_key_sentinel; }
 
     /**
      * @brief Gets the sentinel value used to represent an empty value slot.
      *
      * @return The sentinel value used to represent an empty value slot
      */
-    __host__ __device__ Value get_empty_value_sentinel() const noexcept
-    {
-      return empty_value_sentinel_;
-    }
+    static constexpr Value get_empty_value_sentinel() { return empty_value_sentinel; }
 
-    __host__ __device__ Key get_erased_key_sentinel() const noexcept
-    {
-      return erased_key_sentinel_;
-    }
+    static constexpr Key get_erased_key_sentinel() { return erased_key_sentinel; }
 
     /**
      * @brief Returns iterator to the first slot.
@@ -690,19 +618,12 @@ class static_map {
      */
     __device__ const_iterator begin_slot() const noexcept { return slots_; }
 
-    /**
-     * @brief Returns a const_iterator to one past the last slot.
-     *
-     * @return A const_iterator to one past the last slot
-     */
-    __host__ __device__ const_iterator end_slot() const noexcept { return slots_ + capacity_; }
-
     /**
      * @brief Returns an iterator to one past the last slot.
      *
      * @return An iterator to one past the last slot
      */
-    __host__ __device__ iterator end_slot() noexcept { return slots_ + capacity_; }
+    __host__ __device__ iterator end_slot() const noexcept { return slots_ + capacity_; }
 
     /**
      * @brief Returns a const_iterator to one past the last slot.
@@ -712,17 +633,7 @@ class static_map {
      *
      * @return A const_iterator to one past the last slot
      */
-    __host__ __device__ const_iterator end() const noexcept { return end_slot(); }
-
-    /**
-     * @brief Returns an iterator to one past the last slot.
-     *
-     * `end()` calls `end_slot()` and is provided for convenience for those familiar with checking
-     * an iterator returned from `find()` against the `end()` iterator.
-     *
-     * @return An iterator to one past the last slot
-     */
-    __host__ __device__ iterator end() noexcept { return end_slot(); }
+    __host__ __device__ iterator end() const noexcept { return end_slot(); }
   };
 
  public:
@@ -746,7 +657,7 @@ class static_map {
    *                  });
    * \endcode
    */
-  class device_mutable_view : public device_view_base {
+  class __align__(16) device_mutable_view : public device_view_base {
    public:
     using value_type  = typename device_view_base::value_type;   ///< Type of key/value pairs
     using key_type    = typename device_view_base::key_type;     ///< Key type
@@ -764,40 +675,14 @@ class static_map {
      *
      * @param slots Pointer to beginning of initialized slots array
      * @param capacity The number of slots viewed by this object
-     * @param empty_key_sentinel The reserved value for keys to represent empty slots
-     * @param empty_value_sentinel The reserved value for mapped values to
-     * represent empty slots
      */
     __host__ __device__
     device_mutable_view(pair_atomic_type* slots,
-                        std::size_t capacity,
-                        sentinel::empty_key<Key> empty_key_sentinel,
-                        sentinel::empty_value<Value> empty_value_sentinel) noexcept
-      : device_view_base{slots, capacity, empty_key_sentinel, empty_value_sentinel}
+                        std::size_t capacity) noexcept
+      : device_view_base{slots, capacity}
     {
     }
 
-    /**
-     * @brief Constructs a mutable view of the first `capacity` slots of the
-     * slots array pointed to by `slots`.
-     *
-     * @param slots Pointer to beginning of initialized slots array
-     * @param capacity The number of slots viewed by this object
-     * @param empty_key_sentinel The reserved value for keys to represent empty slots
-     * @param empty_value_sentinel The reserved value for mapped values to represent empty slots
-     * @param erased_key_sentinel The reserved value for keys to represent erased slots
-     */
-    __host__ __device__ device_mutable_view(pair_atomic_type* slots,
-                                            std::size_t capacity,
-                                            sentinel::empty_key<Key> empty_key_sentinel,
-                                            sentinel::empty_value<Value> empty_value_sentinel,
-                                            sentinel::erased_key<Key> erased_key_sentinel) noexcept
-      : device_view_base{
-          slots, capacity, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel}
-    {
-    }
-
-   private:
     /**
      * @brief Enumeration of the possible results of attempting to insert into a hash bucket.
      */
@@ -860,64 +745,6 @@ class static_map {
                                                  Key expected_key) noexcept;
 
    public:
-    /**
-     * @brief Given a slot pointer `slots`, initializes the first `capacity` slots with the given
-     * sentinel values and returns a `device_mutable_view` object of those slots.
-     *
-     * @tparam CG The type of the cooperative thread group
-     *
-     * @param g The cooperative thread group used to copy the slots
-     * @param slots Pointer to the hash map slots
-     * @param capacity The total number of slots in the map
-     * @param empty_key_sentinel The reserved value for keys to represent empty slots
-     * @param empty_value_sentinel The reserved value for mapped values to represent empty slots
-     * @return A device_mutable_view object based on the given parameters
-     */
-    template <typename CG>
-    __device__ static device_mutable_view make_from_uninitialized_slots(
-      CG const& g,
-      pair_atomic_type* slots,
-      std::size_t capacity,
-      sentinel::empty_key<Key> empty_key_sentinel,
-      sentinel::empty_value<Value> empty_value_sentinel) noexcept
-    {
-      device_view_base::initialize_slots(
-        g, slots, capacity, empty_key_sentinel.value, empty_value_sentinel.value);
-      return device_mutable_view{slots,
-                                 capacity,
-                                 empty_key_sentinel,
-                                 empty_value_sentinel,
-                                 sentinel::erased_key<Key>{empty_key_sentinel.value}};
-    }
-
-    /**
-     * @brief Given a slot pointer `slots`, initializes the first `capacity` slots with the given
-     * sentinel values and returns a `device_mutable_view` object of those slots.
-     *
-     * @tparam CG The type of the cooperative thread group
-     *
-     * @param g The cooperative thread group used to copy the slots
-     * @param slots Pointer to the hash map slots
-     * @param capacity The total number of slots in the map
-     * @param empty_key_sentinel The reserved value for keys to represent empty slots
-     * @param empty_value_sentinel The reserved value for mapped values to represent empty slots
-     * @param erased_key_sentinel The reserved value for keys to represent erased slots
-     * @return A device_mutable_view object based on the given parameters
-     */
-    template <typename CG>
-    __device__ static device_mutable_view make_from_uninitialized_slots(
-      CG const& g,
-      pair_atomic_type* slots,
-      std::size_t capacity,
-      sentinel::empty_key<Key> empty_key_sentinel,
-      sentinel::empty_value<Value> empty_value_sentinel,
-      sentinel::erased_key<Key> erased_key_sentinel) noexcept
-    {
-      device_view_base::initialize_slots(
-        g, slots, capacity, empty_key_sentinel, empty_value_sentinel);
-      return device_mutable_view{
-        slots, capacity, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel};
-    }
 
     /**
      * @brief Inserts the specified key/value pair into the map.
@@ -1047,7 +874,7 @@ class static_map {
    * value.
    *
    */
-  class device_view : public device_view_base {
+  class __align__(16) device_view : public device_view_base {
    public:
     using value_type  = typename device_view_base::value_type;   ///< Type of key/value pairs
     using key_type    = typename device_view_base::key_type;     ///< Key type
@@ -1065,34 +892,10 @@ class static_map {
      *
      * @param slots Pointer to beginning of initialized slots array
      * @param capacity The number of slots viewed by this object
-     * @param empty_key_sentinel The reserved value for keys to represent empty slots
-     * @param empty_value_sentinel The reserved value for mapped values to represent empty slots
      */
     __host__ __device__ device_view(pair_atomic_type* slots,
-                                    std::size_t capacity,
-                                    sentinel::empty_key<Key> empty_key_sentinel,
-                                    sentinel::empty_value<Value> empty_value_sentinel) noexcept
-      : device_view_base{slots, capacity, empty_key_sentinel, empty_value_sentinel}
-    {
-    }
-
-    /**
-     * @brief Construct a view of the first `capacity` slots of the
-     * slots array pointed to by `slots`.
-     *
-     * @param slots Pointer to beginning of initialized slots array
-     * @param capacity The number of slots viewed by this object
-     * @param empty_key_sentinel The reserved value for keys to represent empty slots
-     * @param empty_value_sentinel The reserved value for mapped values to represent empty slots
-     * @param erased_key_sentinel The reserved value for keys to represent erased slots
-     */
-    __host__ __device__ device_view(pair_atomic_type* slots,
-                                    std::size_t capacity,
-                                    sentinel::empty_key<Key> empty_key_sentinel,
-                                    sentinel::empty_value<Value> empty_value_sentinel,
-                                    sentinel::erased_key<Key> erased_key_sentinel) noexcept
-      : device_view_base{
-          slots, capacity, empty_key_sentinel, empty_value_sentinel, erased_key_sentinel}
+                                    std::size_t capacity) noexcept
+      : device_view_base{slots, capacity}
     {
     }
 
@@ -1103,84 +906,8 @@ class static_map {
      */
     __host__ __device__ explicit device_view(device_mutable_view mutable_map)
       : device_view_base{mutable_map.get_slots(),
-                         mutable_map.get_capacity(),
-                         sentinel::empty_key<Key>{mutable_map.get_empty_key_sentinel()},
-                         sentinel::empty_value<Value>{mutable_map.get_empty_value_sentinel()},
-                         sentinel::erased_key<Key>{mutable_map.get_erased_key_sentinel()}}
-    {
-    }
-
-    /**
-     * @brief Makes a copy of given `device_view` using non-owned memory.
-     *
-     * This function is intended to be used to create shared memory copies of small static maps,
-     * although global memory can be used as well.
-     *
-     * Example:
-     * @code{.cpp}
-     * template <typename MapType, int CAPACITY>
-     * __global__ void use_device_view(const typename MapType::device_view device_view,
-     *                                 map_key_t const* const keys_to_search,
-     *                                 map_value_t* const values_found,
-     *                                 const size_t number_of_elements)
-     * {
-     *     const size_t index = blockIdx.x * blockDim.x + threadIdx.x;
-     *
-     *     __shared__ typename MapType::pair_atomic_type sm_buffer[CAPACITY];
-     *
-     *     auto g = cg::this_thread_block();
-     *
-     *     const map_t::device_view sm_static_map = device_view.make_copy(g,
-     *                                                                    sm_buffer);
-     *
-     *     for (size_t i = g.thread_rank(); i < number_of_elements; i += g.size())
-     *     {
-     *         values_found[i] = sm_static_map.find(keys_to_search[i])->second;
-     *     }
-     * }
-     * @endcode
-     *
-     * @tparam CG The type of the cooperative thread group
-     * @param g The ooperative thread group used to copy the slots
-     * @param source_device_view `device_view` to copy from
-     * @param memory_to_use Array large enough to support `capacity` elements. Object does not take
-     * the ownership of the memory
-     * @return Copy of passed `device_view`
-     */
-    template <typename CG>
-    __device__ static device_view make_copy(CG g,
-                                            pair_atomic_type* const memory_to_use,
-                                            device_view source_device_view) noexcept
+                         mutable_map.get_capacity()}
     {
-#if defined(CUDA_HAS_CUDA_BARRIER)
-      __shared__ cuda::barrier<cuda::thread_scope::thread_scope_block> barrier;
-      if (g.thread_rank() == 0) { init(&barrier, g.size()); }
-      g.sync();
-
-      cuda::memcpy_async(g,
-                         memory_to_use,
-                         source_device_view.get_slots(),
-                         sizeof(pair_atomic_type) * source_device_view.get_capacity(),
-                         barrier);
-
-      barrier.arrive_and_wait();
-#else
-      pair_atomic_type const* const slots_ptr = source_device_view.get_slots();
-      for (std::size_t i = g.thread_rank(); i < source_device_view.get_capacity(); i += g.size()) {
-        new (&memory_to_use[i].first)
-          atomic_key_type{slots_ptr[i].first.load(cuda::memory_order_relaxed)};
-        new (&memory_to_use[i].second)
-          atomic_mapped_type{slots_ptr[i].second.load(cuda::memory_order_relaxed)};
-      }
-      g.sync();
-#endif
-
-      return device_view(
-        memory_to_use,
-        source_device_view.get_capacity(),
-        sentinel::empty_key<Key>{source_device_view.get_empty_key_sentinel()},
-        sentinel::empty_value<Value>{source_device_view.get_empty_value_sentinel()},
-        sentinel::erased_key<Key>{source_device_view.get_erased_key_sentinel()});
     }
 
     /**
@@ -1248,32 +975,6 @@ class static_map {
               typename Hash     = cuco::detail::MurmurHash3_32<key_type>,
               typename KeyEqual = thrust::equal_to<key_type>>
     __device__ iterator
-    find(CG g, Key const& k, Hash hash = Hash{}, KeyEqual key_equal = KeyEqual{}) noexcept;
-
-    /**
-     * @brief Finds the value corresponding to the key `k`.
-     *
-     * Returns a const_iterator to the pair whose key is equivalent to `k`.
-     * If no such pair exists, returns `end()`. Uses the CUDA Cooperative Groups API to
-     * to leverage multiple threads to perform a single find. This provides a
-     * significant boost in throughput compared to the non Cooperative Group
-     * `find` at moderate to high load factors.
-     *
-     * @tparam CG Cooperative Group type
-     * @tparam Hash Unary callable type
-     * @tparam KeyEqual Binary callable type
-     * @param g The Cooperative Group used to perform the find
-     * @param k The key to search for
-     * @param hash The unary callable used to hash the key
-     * @param key_equal The binary callable used to compare two keys
-     * for equality
-     * @return An iterator to the position at which the key/value pair
-     * containing `k` was inserted
-     */
-    template <typename CG,
-              typename Hash     = cuco::detail::MurmurHash3_32<key_type>,
-              typename KeyEqual = thrust::equal_to<key_type>>
-    __device__ const_iterator
     find(CG g, Key const& k, Hash hash = Hash{}, KeyEqual key_equal = KeyEqual{}) const noexcept;
 
     /**
@@ -1370,21 +1071,21 @@ class static_map {
    *
    * @return The sentinel value used to represent an empty key slot
    */
-  Key get_empty_key_sentinel() const noexcept { return empty_key_sentinel_; }
+  static constexpr Key get_empty_key_sentinel() { return empty_key_sentinel_; }
 
   /**
    * @brief Gets the sentinel value used to represent an empty value slot.
    *
    * @return The sentinel value used to represent an empty value slot
    */
-  Value get_empty_value_sentinel() const noexcept { return empty_value_sentinel_; }
+  static constexpr Value get_empty_value_sentinel() { return empty_value_sentinel_; }
 
   /**
    * @brief Gets the sentinel value used to represent an erased value slot.
    *
    * @return The sentinel value used to represent an erased value slot
    */
-  Key get_erased_key_sentinel() const noexcept { return erased_key_sentinel_; }
+  static constexpr Key get_erased_key_sentinel() { return erased_key_sentinel_; }
 
   /**
    * @brief Constructs a device_view object based on the members of the `static_map` object.
@@ -1394,10 +1095,7 @@ class static_map {
   device_view get_device_view() const noexcept
   {
     return device_view(slots_,
-                       capacity_,
-                       sentinel::empty_key<Key>{empty_key_sentinel_},
-                       sentinel::empty_value<Value>{empty_value_sentinel_},
-                       sentinel::erased_key<Key>{erased_key_sentinel_});
+                       capacity_);
   }
 
   /**
@@ -1408,19 +1106,15 @@ class static_map {
   device_mutable_view get_device_mutable_view() const noexcept
   {
     return device_mutable_view(slots_,
-                               capacity_,
-                               sentinel::empty_key<Key>{empty_key_sentinel_},
-                               sentinel::empty_value<Value>{empty_value_sentinel_},
-                               sentinel::erased_key<Key>{erased_key_sentinel_});
+                               capacity_);
   }
 
- private:
   pair_atomic_type* slots_{nullptr};            ///< Pointer to flat slots storage
   std::size_t capacity_{};                      ///< Total number of slots
   std::size_t size_{};                          ///< Number of keys in map
-  Key empty_key_sentinel_{};                    ///< Key value that represents an empty slot
-  Value empty_value_sentinel_{};                ///< Initial value of empty slot
-  Key erased_key_sentinel_{};                   ///< Key value that represents an erased slot
+  static constexpr Key empty_key_sentinel_ = empty_key_sentinel;                    ///< Key value that represents an empty slot
+  static constexpr Value empty_value_sentinel_ = empty_value_sentinel;                ///< Initial value of empty slot
+  static constexpr Key erased_key_sentinel_ = erased_key_sentinel;                   ///< Key value that represents an erased slot
   atomic_ctr_type* num_successes_{};            ///< Number of successfully inserted keys on insert
   slot_allocator_type slot_allocator_{};        ///< Allocator used to allocate slots
   counter_allocator_type counter_allocator_{};  ///< Allocator used to allocate `num_successes_`
diff --git a/include/cuco/traits.hpp b/include/cuco/traits.hpp
index 445a40d..07fe954 100644
--- a/include/cuco/traits.hpp
+++ b/include/cuco/traits.hpp
@@ -17,6 +17,7 @@
 #pragma once
 
 #include <type_traits>
+#include <cuco/detail/pair.cuh>
 
 namespace cuco {
 
